[[pulsar]]
=== Using Spring for Apache Pulsar

:javadocs: https://docs.spring.io/spring-pulsar/docs/current-SNAPSHOT/api
:github: https://github.com/spring-projects-experimental/spring-pulsar

This section offers detailed explanations of the various concerns that impact using Spring for Apache Pulsar.
For a quick but less detailed introduction, see <<index.adoc#quick-intro>>.

[[pulsar-client]]
==== Pulsar Client

When using the Pulsar Spring Boot Starter, you get the `PulsarClient` auto-configured.
This is done through a factory bean called `PulsarClientFactoryBean`, which takes a configuration object `PulsarClientConfiguration`. By default, the application tries to connect to a local Pulsar instance at `pulsar://localhost:6650`. However, there are many application properties available to configure the client.

.[.underline]#Click ##here## to view the available **Pulsar Client Properties**#.
[%collapsible]
====
include::application-properties/pulsar-client.adoc[lines=3..-1]
====


[[pulsar-producer]]
==== Pulsar Producer

On the Pulsar producer side, Spring Boot auto-configuration provides a `PulsarTemplate` for publishing records. The template implements an interface called `PulsarOperations` and provides {javadocs}/org/springframework/pulsar/core/PulsarOperations.html[several variants of 'send' methods] to publish records through its contract.

There are two categories of these send API methods - `send` and `sendAsync`.
The `send` methods are blocking calls using the synchronous sending capabilities on the Pulsar producer.
They return the `MessageId` of the message that was published once the message is persisted on the broker.
The `sendAsync` method calls are asynchronous calls that are non-blocking.
They return a `CompletableFuture` using which you can asynchronously receive the message id once the messages are published.

Both `send` and `sendAsync` methods have a variant that allows to publish simply with the message.
When you do that, the application must provide the topic name using the property `spring.pulsar.producer.topicName`.
There is another variant for both flavors that takes the topic name as an argument.

The methods using a `TypedMessageBuilderCustomizer` allow modifying the basic `TypedMessageBuilder`.
This can be used to send a keyed message for example:

====
[source, java]
----
template.send(msg, (messageBuilder -> messageBuilder.key(myMessageKey)));
----
====

If you are using simple Java primitive types, then the framework auto-detects the schema for you, and you do not need to specify any schema types for publishing the data.
However, if you are using any complex types such as `JSON`, `AVRO`, `PROTOBUF`, etc. then you need to set the proper schema type on the `PulsarTemplate` before invoking any send operations as shown below.

====
[source, java]
----
pulsarTemplate.setSchema(Schema.JSON(Foo.class));
----
====


When using partitioned topics, then you can use custom partitioning routing when publishing records.
For this purpose, you can provide an implementation of a `MessageRouter` and pass it along with both `send` and `sendAsync` methods.
Note that, when using a `MessageRouter`, you must set the `spring.pulsar.producer.messageRoutingMode` property to `custom`.

[[producer-application-properties]]
.[.underline]#Click ##here## to view the available **Pulsar Producer Properties**#
[%collapsible]
====
include::application-properties/pulsar-producer.adoc[lines=3..-1]
====

[[pulsar-producer-factory]]
==== Pulsar Producer Factory
The `PulsarTemplate` relies on a `PulsarProducerFactory` for actually creating the underlying producer. Spring Boot auto-configuration also provides this producer factory. Additionally, you can configure the factory by specifying any of the available producer-centric application properties <<producer-application-properties,listed above>>.

[[producer-caching]]
==== Pulsar Producer Caching
Each underlying Pulsar producer consumes resources. In order to improve performance and avoid continual creation of producers, the producer factory caches the producers that it creates. They are cached in an LRU fashion and evicted when they have not been used within a configured time period. The link:{github}/blob/8e33ac0b122bc0e75df299919c956cacabcc9809/spring-pulsar/src/main/java/org/springframework/pulsar/core/CachingPulsarProducerFactory.java#L159[cache key] is composed of just enough information to ensure that callers are returned the same producer on subsequent creation requests.

Additionally, you can configure the cache settings by specifying any of the `spring.producer.cache` prefixed application properties <<producer-application-properties,listed above>>.


[[pulsar-listener]]
==== Pulsar Listener

When it comes to Pulsar consumer, we recommend the end user applications to make use of the `PulsarListener` annotation.
In order to use `PulsarListener`, you need to use the `@EnablePulsar` annotation.
When using the Spring Boot support, it automatically enables this annotation and configures all the components necessary for `PulsarListener` such as the message listener infrastructure which is responsible for creating the Pulsar consumer.
`PulsarMessageListenerContainer` uses a `PulsarConsumerFactory` in order to create and manage the Pulsar consumer.
This consumer factory is also auto-configured through Spring Boot.

.[.underline]#Click ##here## to view the available **Pulsar Consumer Properties**#
[%collapsible]
====
include::application-properties/pulsar-consumer.adoc[lines=3..-1]
====

Let us revisit the `PulsarListener` code snippet we saw in the quick-tour section.

====
[source, java]
----
@PulsarListener(subscriptionName = "hello-pulsar-subscription", topics = "hello-pulsar")
public void listen(String message) {
    System.out.println("Message Received: " + message);
}
----
====

This can even be further simplified as below.

====
[source, java]
----
@PulsarListener
public void listen(String message) {
    System.out.println("Message Received: " + message);
}
----
====

In this most basic form, you must provide the following two properties with their corresponding values.

[source,yaml,indent=0,subs="verbatim"]
----
spring.pulsar.consumer:
  topic-names: hello-pulsar
  subscription-name: hello-pulsar-subscription
----

In the `PulsarListener` method above, we receive the data as `String`, but we don't specify any schema types.
Internally, the framework relies on Pulsar's schema mechanism to convert the data to the required type.
The framework detects that you are expecting the `String` type and then infers the schema type based on that information.
Then it provides that schema to the consumer.
For all the primitive types in Java, the framework does this inference.
For any complex types, such as JSON, AVRO etc. the framework cannot do this inference and the user needs to provide the schema type on the annotation using the `schemaType` property.

Here is another `PulsarListener` method, that takes an `Integer`.

====
[source, java]
----
@PulsarListener(subscriptionName = "my-subscription-1", topics = "my-topic-1")
public void listen2(Integer message) {
   System.out.println(message);
}
----
====

The following `PulsarListener` method shows how we can consume complex types from a topic

====
[source, java]
----
@PulsarListener(subscriptionName = "my-subscription-2", topics = "my-topic-2", schemaType = SchemaType.JSON)
public void listen3(Foo message) {
    System.out.println(message);
}
----
====

Note the addition of a `schemaType` property on `PulsarListener`.
That is because the library is not capable of inferring the schema type from the provided type `Foo`, we must tell the framework what schema to use.

Here is an example of using `PulsarListener` to consume records in batches.

====
[source, java]
----
@PulsarListener(subscriptionName = "hello-batch-subscription", topics = "hello-batch", schemaType = SchemaType.JSON, batch = true)
public void listen4(List<Foo> messages) {
    System.out.println("records received :" + messages.size());
    messages.forEach((message) -> System.out.println("record : " + message));
}
----
====

Note that in this example, we are receiving the records as a collection (`List`) of objects.
In addition, in order to enable batch consumption at the `PulsarListener` level, you need to set the `batch` property on the annotation to `true`.

Based on the actual type that the `List` holds, the framework tries to infer the schema to use.
If the `List` contains a complex type, then the `schemaType` still needs to be provided on `PulsarListener`.

The following also should work in which we use the `Messages` holder type provided by the Pulsar Java client.

====
[source, java]
----
@PulsarListener(subscriptionName = "hello-batch-subscription", topics = "hello-batch", schemaType = SchemaType.JSON, batch = true)
public void listen4(Messages<Foo> messages) {
    System.out.println("records received :" + messages.size());
    messages.forEach((message) -> System.out.println("record : " + message));
}
----
====

When using `PulsarListener`, you can provide Pulsar consumer properties directly on the annotation itself.
This is convenient, if you do not want to use the Boot configuration properties mentioned above or have multiple `PulsarListener` methods.

Here is an example of using Pulsar consumer properties directly on `PulsarListener`.

====
[source, java]
----
@PulsarListener(properties = { "subscriptionName=subscription-1", "topicNames=foo-1", "receiverQueueSize=5000" })
void listen(String message) {
}
----
====

Note that the properties used are direct Pulsar consumer properties.

[[pulsar-message-listener-container]]
==== Pulsar Message Listener Container

As briefly mentioned above, the message listener container is at the heart of message consumption when using Spring for Apache Pulsar.
`PulsarListener` uses the message listener container infrastructure behind the scenes to create and manage the Pulsar consumer.
Spring for Apache Pulsar provides the contract for this message listener container through `PulsarMessageListenerContainer`.
The default implementation for this message listener container is provided through `DefaultPulsarMessageListenerContainer`.
As its name indicates, `PulsarMessageListenerContainer` contains the message listener.
The container creates the Pulsar consumer and then runs a separate thread to receive and handle the data.
The data is handled by the provided message listener implementation.

The message listener container consumes the data in batch using the consumer's `batchReceive` method.
Once data is received, it is handed over to the selected message listener implementation.

The following message listener types are available when using Spring for Apache Pulsar.

* link:{github}/blob/8e33ac0b122bc0e75df299919c956cacabcc9809/spring-pulsar/src/main/java/org/springframework/pulsar/listener/PulsarRecordMessageListener.java#L29[PulsarRecordMessageListener]

* link:{github}/blob/ade2c74482d8ac1407ffe4840fa058475c07bcfc/spring-pulsar/src/main/java/org/springframework/pulsar/listener/PulsarAcknowledgingMessageListener.java#L28[PulsarAcknowledgingMessageListener]

* link:{github}/blob/ade2c74482d8ac1407ffe4840fa058475c07bcfc/spring-pulsar/src/main/java/org/springframework/pulsar/listener/PulsarBatchMessageListener.java#L36[PulsarBatchMessageListener]

* link:{github}/blob/ade2c74482d8ac1407ffe4840fa058475c07bcfc/spring-pulsar/src/main/java/org/springframework/pulsar/listener/PulsarBatchAcknowledgingMessageListener.java#L28[PulsarBatchAcknowledgingMessageListener]

We will see the details about these various message listeners in the sections below.

==== Consuming the Records

In this section, we are going to see how the message listener container enables both single record and batch based message consumption.

==== Single Record Consumption

Let us re-visit our basic `PulsarListener` for the sake of this discussion.

====
[source, java]
----
@PulsarListener(subscriptionName = "hello-pulsar-subscription", topics = "hello-pulsar")
public void listen(String message) {
    System.out.println("Message Received: " + message);
}
----
====

With this `PulsarListener` method, what we are essentially doing is that asking Spring for Apache Pulsar to invoke the listener method with a single record each time.
We mentioned that the message listener container consumes the data in batches using the `batchReceive` method on the consumer.
The framework detects that the `PulsarListener` in this case receives a single record which means that on each invocation of the method it needs a singe record.
Although the records are consumed by the message listener container in batches, it iterates through the received batch and then invoke the listener method through an adapter for `PulsarRecordMessageListener`.
As you can see in the previous section, `PulsarRecordMessageListener` simply extends from the `MessageListener` provided by the Pulsar Java client and it supports the basic `received` method.

==== Batch Consumption

Here is the `PulsarListener` example of consuming records in batches.

====
[source, java]
----
@PulsarListener(subscriptionName = "hello-batch-subscription", topics = "hello-batch", schemaType = SchemaType.JSON, batch = true)
public void listen4(List<Foo> messages) {
    System.out.println("records received :" + messages.size());
    messages.forEach((message) -> System.out.println("record : " + message));
}
----
====

When using this type of `PulsarListener`, the framework detects that you are in batch mode.
Since it is already received the data in batches using the Consumer's `batchReceive` method, it simply hands off the entire batch to the listener method through an adapter for `PulsarBatchMessageListener`.

==== Message Acknowledgment

When using Spring for Apache Pulsar, the message acknowledgment is handled by the framework unless opted out by the application.
In this section, we go through the details of how the framework takes care of message acknowledgment.

==== Message ACK modes

Spring for Apache Pulsar provides the following modes for acknowledging messages

```
BATCH,

RECORD,

MANUAL;
```

`BATCH` acknowledgment mode is the default, but you can change it on the message listener container.

==== Message Ack in Single Record Mode

When consuming single records using `PulsarRecordMessageListener` and the default ack mode of `BATCH` is used, the framework waits for all the record received from the `batchReceive` call to process successfully and then call the `acknowledge` method on the Pulsar Consumer.
If any particular record throws an exception when invoking the handler method, Spring for Apache Pulsar tracks those records and separately call `negativeAcknowledge` on those records after the entire batch is processed.

If the application wants the acknowledgment or negative acknowledgment to occur per record, then the `RECORD` ack mode can be enabled.
In that case, after handling each record the message is acknowledged if no error or negatively acknowledged if there was an error.

==== Message Ack in Batch Consumption

When records are consumed in batches (See the section above), then if the default ack mode of `BATCH` is used, then when the entire batch is processed successfully, it will be acknowledged.
If any records throw an exception, then the entire batch is negatively acknowledged.
When consuming in batch mode, `RECORD` is not an allowed ack mode.
This might cause an issue as application does not want the entire batch to be re-delivered again.
For such situations, you need to use the `MANUAL` acknowledgement mode.

==== Manual Acknowledgment

When `MANUAL` ack mode is set on the message listener container, then the framework will not do any acknowledgment - positive or negative.
It is entirely up to the application to take care of such concerns.
When `MANUAL` ack mode is set, Spring for Apache Pulsar selects a compatible message listener container - `PulsarAcknowledgingMessageListener` when in record consumption and `PulsarBatchAcknowledgingMessageListener` for batch consumption.
These interfaces provide you access to an `Acknowledgment` object.
The `Acknowledgment` object provides the following API methods.

====
[source, java]
----
void acknowledge();

void acknowledge(MessageId messageId);

void acknowledge(List<MessageId> messageIds);

void nack();

void nack(MessageId messageId);
----
====

You can inject this `Acknowledgment` object to your `PulsarListener` while using `MANUAL` ack mode and then call the corresponding method.
Here is a basic example for a record based listener.

====
[source, java]
----
@PulsarListener(subscriptionName = "hello-pulsar-subscription", topics = "hello-pulsar")
public void listen(String message, Acknowlegement acknowledgment) {
    System.out.println("Message Received: " + message);
	acknowledgment.acknowledge();
}
----
====

You can also call `acknowledgment.nack()` to negatively acknowledge in which case the record will be re-delivered.

When using a batch listener, the message listener container cannot know which record it is currently operating upon.
Therefore, in order to manually acknowledge, you need to use one of the overloaded `acknowledge` method that takes a `MessageId` or a `List<MessageId>`.
You can also negatively acknowledge with the `MessageId` for the batch listener.

==== Partitioned topics - Publishing and Consuming.

In the sample below, we are publishing to a topic called `hello-pulsar-partitioned`.
It is a topic that is partitioned and for this sample we assume that the topic is already created with three partitions.

====
[source, java]
----
@SpringBootApplication
public class PulsarBootPartitioned {

	public static void main(String[] args) {
		SpringApplication.run(PulsarBootPartitioned.class, "--spring.pulsar.producer.messageRoutingMode=CustomPartition");
	}

	@Bean
	public ApplicationRunner runner(PulsarTemplate<String> pulsarTemplate) {
		pulsarTemplate.setDefaultTopicName("hello-pulsar-partitioned");
		return args -> {
			for (int i = 0; i < 10; i++) {
				pulsarTemplate.sendAsync("hello john doe 0 ", new FooRouter());
				pulsarTemplate.sendAsync("hello alice doe 1", new BarRouter());
				pulsarTemplate.sendAsync("hello buzz doe 2", new BuzzRouter());
			}
		};
	}

	@PulsarListener(subscriptionName = "hello-pulsar-partitioned-subscription", topics = "hello-pulsar-partitioned")
	public void listen(String message) {
		System.out.println("Message Received: " + message);
	}

    static class FooRouter implements MessageRouter {

		@Override
		public int choosePartition(Message<?> msg, TopicMetadata metadata) {
			return 0;
		}
	}

	static class BarRouter implements MessageRouter {

		@Override
		public int choosePartition(Message<?> msg, TopicMetadata metadata) {
			return 1;
		}
	}

	static class BuzzRouter implements MessageRouter {

		@Override
		public int choosePartition(Message<?> msg, TopicMetadata metadata) {
			return 2;
		}
	}

}
----
====

A few things require explanation in the application above.
We are publishing to a partitioned topic and we would like to publish some data segment to a specific partition.
If you leave it to Pulsar's default, it follows a round-robin mode of partition assignments, and we would like to override that.
In order to do that, we are providing a message router object with the send method.
Look at the three message routers implemented.
`FooRouter` always sends data to partition `0`, `BarRouter` to partition `1` and `BuzzRouter` to partition `2`.
Also note that, we are now using the `sendAsync` method of `PulsarTemplate` that returns a `CompletableFuture`.
When running the application, we also need to set the `messageRoutingMode` on the producer to `CustomPartition` (`spring.pulsar.producer.messageRoutingMode`).

On the consumer side, we are using a `PulsarListener` with the exclusive subscription type.
This means that data from all the partitions will end up in the same consumer and there is no ordering guarantee.

What can we do if we want each partition to be consumed by a single distinct consumer?
We can switch to the `failover` subscription mode and add three separate consumers.

Here is an example.

====
[source, java]
----
@PulsarListener(subscriptionName = "hello-pulsar-partitioned-subscription", topics = "hello-pulsar-partitioned", subscriptionType = "failover")
public void listen1(String foo) {
    System.out.println("Message Received 1: " + foo);
}

@PulsarListener(subscriptionName = "hello-pulsar-partitioned-subscription", topics = "hello-pulsar-partitioned", subscriptionType = "failover")
public void listen2(String foo) {
    System.out.println("Message Received 2: " + foo);
}

@PulsarListener(subscriptionName = "hello-pulsar-partitioned-subscription",  topics = "hello-pulsar-partitioned", subscriptionType = "failover")
public void listen3(String foo) {
    System.out.println("Message Received 3: " + foo);
}
----
====

When following this approach, you can see that a single partition always gets consumed by a dedicated consumer.

In the similar vein, if you want to use Pulsar's shared consumer type, you can use the subscription type `shared`.
Keep in mind though, that when using the `shared` mode, you lose any ordering guarantees as a single consumer may receive messages from all the partitions before another consumer gets a chance.

Here is an example.

====
[source, java]
----
@PulsarListener(subscriptionName = "hello-pulsar-shared-subscription", topics = "hello-pulsar-partitioned", subscriptionType = "shared")
public void listen1(String foo) {
    System.out.println("Message Received 1: " + foo);
}

@PulsarListener(subscriptionName = "hello-pulsar-shared-subscription", topics = "hello-pulsar-partitioned", subscriptionType = "shared")
public void listen2(String foo) {
    System.out.println("Message Received 2: " + foo);
}
----
====

==== Accessing the Pulsar Message Object

In your `PulsarListener` method, you can receive the record directly as a Pulsar Message instead of the actual payload type.
Here is an example.

====
[source, java]
----
@PulsarListener(subscriptionName = "hello-pulsar-subscription", topics = "hello-pulsar")
public void listen(org.apache.pulsar.client.api.Message<String> message) {
    System.out.println("Data Received: " + message.getValue());
}
----
====

==== Accessing the Pulsar Messages Object

When consuming messages in batch mode using `PulsarListener`, instead of receiving them as a `List, you can receive them as Pulsar Messages type.
Here is an example.

====
[source, java]
----
@PulsarListener(subscriptionName = "batch-subscription", topics = "hello-pulsar", batch = "true")
public void listen(org.apache.pulsar.client.api.Messages<String> messages) {
    // Iterate on the messages
    // Each iteration gives access to a org.apache.pulsar.client.api.Message object
}
----
====

==== Accessing the Pulsar Consumer Object

Sometimes, it is necessary to gain direct access to the Pulsar Consumer object.
Here is how you may do so.

====
[source, java]
----
@PulsarListener(subscriptionName = "hello-pulsar-subscription", topics = "hello-pulsar")
public void listen(String message, org.apache.pulsar.client.api.Consumer<String> consumer) {
    System.out.println("Message Received: " + message);
    ConsumerStats stats = consumer.getStats();
    ...
}
----
====

When accessing the `Consumer` object this way, make sure NOT to invoke any operations that would change the Consumer's cursor position by invoking any receive methods.
All such operations must be done by the container.

==== Specify schema information

As indicated above, for normal Java types (the primitive ones), Spring Pulsar framework can infer the proper Schema to use on the `PulsarListener`.
However, for more complex types such as JSON or AVRO, you need to specify the schema type on the annotation.
Here is how you provide that.

====
[source, java]
----
@PulsarListener(subscriptionName = "json-subscription", topics = "hello-pulsar-json", schemaType = SchemaType.JSON)
public void listen(Foo foo) {
    System.out.println("Message received: " + foo);
}
----
====

On the producer side also, for the Java primitive types, the framework can infer the Schema, but for any other types, you need set that on the `PulsarTemmplate`.


=== Intercepting messages

==== Intercept messages on the Producer
Adding a `ProducerInterceptor`  allows you to intercept and mutate messages received by the producer before being published to the brokers.
To do so, you can pass a list of interceptors into the `PulsarTemplate` constructor.
When using multiple interceptors, the order they are applied in will be the order they appear in the list.

If you are using Spring Boot auto-configuration, you can simply specify the interceptors as Beans.
They will be passed automatically to the `PulsarTemplate`.
Ordering of the interceptors is achieved by using the `@Order` annotation as seen below.

====
[source, java]
----
@Bean
@Order(100)
ProducerInterceptor firstInterceptor() {
  ...
}

@Bean
@Order(200)
ProducerInterceptor secondInterceptor() {
  ...
}
----
====

[[pulsar-admin]]
==== Pulsar Admin
On the Pulsar administration side, Spring Boot auto-configuration provides a `PulsarAdministration` to manage Pulsar clusters.
The administration implements an interface called `PulsarAdminOperations` and provides {javadocs}/org/springframework/pulsar/core/PulsarAdminOperations.html[a 'createOrModify' method] to handle topic administration through its contract.

When using the Pulsar Spring Boot Starter, you get the `PulsarAdministration` auto-configured.
By default, the application tries to connect to a local Pulsar instance at `http://localhost:8080`. However, there are many application properties available to configure the client.

.[.underline]#Click ##here## to view the available **Pulsar Administration Properties**#.
[%collapsible]
====
include::application-properties/pulsar-administration.adoc[lines=3..-1]
====

On initialization, the `PulsarAdministration` checks if there are any `PulsarTopic` beans in the application context.
For all such beans, the `PulsarAdministration` will either create the corresponding topic, or if necessary modify the number of partitions.

Below is an example how to add `PulsarTopic` beans to let the `PulsarAdministration` auto-create topics for you.

====
[source,java]
----
@Bean
PulsarTopic simpleTopic {
	// This will create a non-partitioned topic in the public/default namespace
	return PulsarTopic.builder("simple-topic").build();
}

@Bean
PulsarTopic partitionedTopic {
	// This will create a partitioned topic with 3 partitions in the provided tenant and namespace
	return PulsarTopic.builder("persistent://my-tenant/my-namespace/partitioned-topic", 3).build();
}
----
====


==== Appendix
The reference documentation has the following appendices:

[horizontal]
<<application-properties#appendix.application-properties,Application Properties>> :: Application properties that you can use to configure your Pulsar application.
