[[tombstones]]
= Null Payloads and Log Compaction of 'Tombstone' Records

When using log compaction, you can send and receive messages with `null` payloads to identify the deletion of a key.
You can also receive `null` values for other reasons, such as a deserializer that might return `null` when it cannot deserialize a value.

To send a `null` payload by using the `PulsarTemplate`, you can use the fluent API and pass null into the value argument of the `newMessage()` method, for example:
[source, java]
----
pulsarTemplate
        .newMessage(null)
        .withTopic("my-topic")
        .withSchema(Schema.STRING)
        .withMessageCustomizer((mb) -> mb.key("key:1234"))
        .send();
----
NOTE: When sending null values you must specify the schema type as the system can not determine the type of the message from a `null` payload.

To configure the `@PulsarListener` to handle `null` payloads, you must use the `@Payload` annotation with `required = false`.
If it is a tombstone message for a compacted log, you usually also need the key so that your application can determine which key was +++"+++`deleted`+++"+++.
The following example shows such a configuration:

[source, java]
----
@PulsarListener(
        topics = "my-topic",
        subscriptionName = "my-topic-sub",
        schemaType = SchemaType.STRING)
void myListener(
        @Payload(required = false) String msg,
        @Header(PulsarHeaders.KEY) String key) {
    ...
}
----

TIP: Additionally, when using the Spring `org.springframework.messaging.Message` for your listener payload type, its generic type information must be wide enough to accept `Message<PulsarNull>` (eg. `Message`, `Message<?>`, or `Message<Object>`).
This is due to the fact that the Spring Message does not allow null values for its payload and instead uses the `PulsarNull` placeholder.
